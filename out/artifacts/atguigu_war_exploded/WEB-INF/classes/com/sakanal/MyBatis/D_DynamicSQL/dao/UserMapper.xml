<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.sakanal.MyBatis.D_DynamicSQL.mapper.UserMapper">

    <!--
        if：判断
            查询员工；要求：携带了哪个字段查询条件就带上这个字段的值
        choose：分支选择；类似JSTL中的带了break的switch-case(when,otherwise)
            查询员工；要求：如果带了id就有id查询，如果带了name就有name查询；只会进入其中一个
        trim：字符串截取(where（封装查询条件）,set（封装修改条件）)
        foreach
    -->
    <!--查询员工；要求：携带了哪个字段查询条件就带上这个字段的值-->
    <select id="getUserByConditionIf" resultType="com.sakanal.MyBatis.D_DynamicSQL.pojo.User">
        select * from `user`
        <!--where-->
        <where>
            <!--
                查询的时候如果某些条件没带可能sql拼接会有问题
                1、给where后面加上1=1，以后的条件都为：and XXX
                2、mybatis使用where标签来将所有的查询条件包括在内,mybatis就会将where标签中拼装的sql，前面多出来的and或者or去掉（只会去掉前面的）
            -->
            <!--test：判断表达式（OGNL）；OGNL参照官方文档使用；类似JSTL：c:if   test
                    从参数中取值进行判断
                    预见特殊符号应该去写转义字符
                    ''   =>  &quot;&quot;
                    &&   =>  &amp;&amp;
            -->
            <if test="id!=null">id=#{id}</if>
            <if test="name!=null and name!=''">and name=#{name}</if>
            <!--OGNL会进行字符串与数字的转换判断  "0"==0-->
            <if test="gender==0 or gender==1">and gender=#{gender}</if>
            <if test="address!=null and address.trim()!=''">and address=#{address}</if>
        </where>
    </select>


    <select id="getUserByConditionTrim" resultType="com.sakanal.MyBatis.D_DynamicSQL.pojo.User">
        select * from `user`
        <!--trim：自定义字符串的截取规则-->
        <!--
            后面多出的and或者or where标签不能解决
            prefix=""           :前缀；trim标签体中是整个字符串拼串后的结果
                                prefix给拼串后的整个字符串加一个前缀
            prefixOverrides=""  ：前缀覆盖；去掉整个字符串前面多余的字符
            suffix=""           ：后缀；
                                suffix给拼串后的整个字符串加一个后缀
            suffixOverrides=""  ：后缀覆盖；去掉整个字符串后面多余的字符
        -->
        <trim prefix="where" suffixOverrides="and">
            <if test="id!=null">id=#{id} and</if>
            <if test="name!=null and name!=''">name=#{name} and</if>
            <if test="gender==0 or gender==1">gender=#{gender} and</if>
            <if test="address!=null and address.trim()!=''">address=#{address}</if>
        </trim>
    </select>





    <!--查询员工；要求：如果带了id就有id查询，如果带了name就有name查询；只会进入其中一个-->
    <select id="getUserByConditionChoose" resultType="com.sakanal.MyBatis.D_DynamicSQL.pojo.User">
        select * from `user`
        <where>
            <choose>
                <when test="id!=null">
                    id=#{id}
                </when>
                <when test="name!=null">
                    name like #{name}
                </when>
                <when test="gender!=null">
                    gender=#{gender}
                </when>
                <otherwise>
                    1=1
                </otherwise>
            </choose>
        </where>
    </select>

    <select id="getUserByConditionForeach" resultType="com.sakanal.MyBatis.D_DynamicSQL.pojo.User">
        select * from `user` where id in
        <!--
            collection：指定要遍历出的元素(传入参数的类型集合)
                list类型的参数会特殊处理封装在map中，map的key就叫list
            item：将当前遍历出的元素赋值给指定的变量
            separator：每个元素之间的分隔符
            open：遍历出的所有结果拼接一个开始的字符
            close：遍历出的所有结果拼接一个结束的字符
            index：遍历list的时候index是索引，item就是当前的值
                   遍历map的时候index是map的key，item就是map的value

            #{变量名}就能取出变量的值也就是当前遍历出的元素
        -->
        <foreach collection="ids" item="item_id" separator="," open="(" close=")">
            #{item_id}
        </foreach>
    </select>









    <update id="updateUser">
        update `user`
        <!--set标签的使用-->
        <set>
            <if test="name!=null">name=#{name},</if>
            <if test="password!=null">password=#{password},</if>
            <if test="address!=null">address=#{address},</if>
        </set>
        <!--trim标签的使用-->
<!--        <trim prefix="set" suffixOverrides=",">-->
<!--            <if test="name!=null">name=#{name},</if>-->
<!--            <if test="password!=null">password=#{password},</if>-->
<!--            <if test="address!=null">address=#{address}</if>-->
<!--        </trim>-->
        where id=#{id}
    </update>





    <!--批量保存-->
    <!--MySQL下批量保存：可以foreach遍历 mysql支持value(),(),()语法-->
    <insert id="insertUsers">
        insert into user(
        <!--引用外部定义的sql-->
        <include refid="insertColumn"/>
                         )
        value
        <foreach collection="users" item="user" separator=",">
            (#{user.id},#{user.name},#{user.password},#{user.gender},#{user.address},#{user.phone},#{user.department.id})
        </foreach>
    </insert>
    <!--这种方式需要数据库连接属性allowMultiQueries=true；这种分号分隔多个sql可以用于其他的批量操作（删除，修改）-->
<!--    <insert id="insertUsers">-->
<!--        <foreach collection="users" item="user" separator=";">-->
<!--            insert into user(id,name,password,gender,address,phone,department_id)-->
<!--            value (#{user.id},#{user.name},#{user.password},#{user.gender},#{user.address},#{user.phone},#{user.department.id})-->
<!--        </foreach>-->
<!--    </insert>-->


    <!--
        两个内置参数：
            不只是方法传递过来的参数可以被用来判断、取值
            mybatis默认还有两个内置参数：
                _parameter：代表整个参数：
                    单个参数：_parameter就是这个参数
                    多个参数：参数会被封装成一个map；_parameter就是代表这个map

                _databaseId：如果配置了databaseIdProvider标签
                    _databaseId就是代表当前数据库的别名
    -->
    <select id="getUserTestInnerParameter" resultType="com.sakanal.MyBatis.D_DynamicSQL.pojo.User">
        <!--bind：可以将OGNL表达式的值绑定到一个变量中，方便后来引用这个变量的值-->
        <bind name="_phone" value="'%'+phone"/>
        <if test="_databaseId=='mysql'">
            select * from `user`
                <if test="_parameter!=null">
                    where phone like #{_phone}
                </if>
        </if>
        <if test="_databaseId=='oracle'">
            select * from `tbl_user`
        </if>
    </select>
    <!--
        抽取可重用的sql片段，方便后面引用
        1、sql抽取：经常将要查询的列名，或者插入用的列名取出来方便使用
        2、include来引用已经抽取的sql
        2、include还可以定义一些property，sql标签内部就能使用的自定义的属性
                include-property（name：value）：取值的正确方式${name}
                                  不能使用#{}
    -->
    <sql id="insertColumn">
        <if test="_databaseId=='mysql'">id,name,password,gender,address,phone,department_id</if>
        <if test="_databaseId=='oracle'">id,name,password,gender,address,phone,department_id</if>
    </sql>
</mapper>